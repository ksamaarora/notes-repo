## üîç Top Docker Interview Questions & Answers

First refer to this - https://www.interviewbit.com/docker-interview-questions/

---

### 1. What is Docker, and why do companies use it?

**Answer:**
Docker is an open-source containerization platform that allows you to package an application and its dependencies into a single portable unit (a container). This container can run consistently across different environments (developer laptop, CI/CD server, cloud). Key reasons companies use Docker:

* **Portability:** Container runs the same everywhere.
* **Consistency:** Avoids ‚Äúit works on my machine‚Äù problems.
* **Resource efficiency:** Multiple containers share the host OS kernel, so lower overhead vs full VMs.
* **Faster development & deployment:** Images can be built, tested, deployed quickly in CI/CD pipelines.
* **Microservices & scalability:** Containers make it easier to deploy small services independently and scale them horizontally.
  ([Razorops][1])

---

### 2. What is the difference between a Docker image and a Docker container?

**Answer:**

* A **Docker image** is a read-only blueprint / template. It includes the application code, dependencies, libraries, runtime and configuration needed to run the app.
* A **Docker container** is a running instance created from that image. It has a read-write layer on top of the image, and is the actual environment in which the app executes.
  You build an image (via a Dockerfile), and then you run containers from it.
  ([Razorops][1])

---

### 3. What are key components of Docker architecture?

**Answer:**
The core components include:

* **Docker Daemon (dockerd):** The server side that manages containers, images, networks, volumes.
* **Docker CLI (client):** The command-line tool developers use (`docker run`, `docker build`, etc.).
* **Docker REST API:** The interface through which the CLI or other tools talk to the daemon.
* **Docker Registry:** A repository (public or private) for storing images (e.g., Docker Hub).
* **Docker Host / engine:** The machine where the daemon runs and containers execute.
  Knowledge of how these interact is important for senior roles.
  ([InterviewBit][2])

---

### 4. How does Docker compare to virtualization (VMs)?

**Answer:**

* **Virtual Machines (VMs):** Each includes a full guest OS on top of a hypervisor on the host OS. Big overhead (RAM, disk), slower to boot.
* **Docker Containers:** Share the host OS kernel, so only the application and dependencies are packaged. Much lighter, faster startup, higher density of workloads per host.
  Because containers are lighter and faster, they‚Äôre well-suited for microservices, rapid deployments, and scalable infrastructure.
  ([DataCamp][3])

---

### 5. Describe the lifecycle of a Docker container.

**Answer:**
Typical lifecycle:

1. **Created** ‚Äì container object created but not yet started.
2. **Running** ‚Äì the main process in the container is executing.
3. **Paused** ‚Äì halted but still retains state (optional).
4. **Stopped** ‚Äì the main process ended.
5. **Removed/Deleted** ‚Äì container object removed, resources cleaned up.
   A senior SDE should also know commands like `docker create`, `docker start`, `docker stop`, `docker rm`, and how to handle ‚Äúdead‚Äù or ‚Äúexited‚Äù containers.
   ([Interview Kickstart][4])

---

### 6. What is a multi-stage Docker build and why is it useful?

**Answer:**
A **multi-stage build** uses multiple `FROM` instructions in a Dockerfile. You use one stage to compile/build your application (with all build dependencies), and then copy only the artifacts you need into a final stage (based on a smaller base image) which becomes your production image.
**Benefits:**

* Smaller final image size.
* Fewer layers and fewer build tools/dependencies in production image => better security & efficiency.
* Cleaner separation between build-time and runtime.
  Advanced roles will expect you to know how to craft efficient Dockerfiles and optimize builds using multi-stage builds.
  ([Medium][5])

---

### 7. Explain Docker networking and different network types in Docker.

**Answer:**
Docker supports several network drivers, the most common being:

* **bridge:** Default network for containers on a single host. Containers communicate via the bridge interface.
* **host:** Container uses the host‚Äôs network stack directly (no isolation of network namespace). Good for low-latency workloads.
* **overlay:** Enables communication between containers on different hosts (useful in a Swarm or Kubernetes cluster).
  You should also know about DNS for containers, service discovery, container linking (older), and how network isolation affects security and performance.
  ([Medium][5])

---

### 8. What are Docker volumes and how do you use them?

**Answer:**

* **Volumes** are the preferred mechanism for persisting data generated by and used by Docker containers.
* They allow data to **persist** even after the container is removed.
* They support sharing data between containers and between host and container.
* Created via `docker volume create` or declared in a `docker-compose.yml` file, and mounted into containers using `-v` or `--mount`.
* Compared to bind mounts, volumes are fully managed by Docker and are more portable/consistent.
  Senior SDEs should additionally know about: named volumes, anonymous volumes, volume drivers, and backup/restore strategies.
  ([Interview Kickstart][4])

---

### 9. How can you ensure your Docker image is secure and minimal?

**Answer:**
Some strategies:

* Use minimal base images (e.g., Alpine or Distroless).
* Remove unnecessary build dependencies in final image (via multi-stage builds).
* Limit number of layers and commands.
* Regularly update base images and dependencies to patch vulnerabilities.
* Use tools like Docker Content Trust, image signing, scanning (e.g., Clair, Trivy) to verify integrity and publishers.
* Harden container runtime: run as non-root user, restrict capabilities, limit resource usage.
  ([Medium][5])

---

### 10. Scenario-Based: ‚ÄúYou‚Äôve built a Docker image for a service. The image size is 1.2 GB, which is too large. How would you reduce it?‚Äù

**Answer:**
Here‚Äôs how I‚Äôd approach it:

* Analyze the current Dockerfile: see base image used, what dependencies are installed, how many layers.
* Choose a smaller base image (e.g., Alpine or scratch).
* Use a **multi-stage build**, so build dependencies are not included in the final image.
* Combine `RUN` commands to reduce number of layers.
* Clean up caches, temporary files after installations (`rm -rf /var/lib/apt/lists/*`, etc.).
* Remove unused dependencies, tools.
* Squash layers where possible (depending on Docker version or build tool).
* Use `.dockerignore` to exclude files/folders you don‚Äôt need in image.
* Use `docker image prune`, `docker system prune` to clear dangling images and layers.
  This demonstrates you know not just commands but real practices.
  ([DataCamp][3])

---

### 11. Scenario-Based: ‚ÄúDuring a merge of two branches, one containerised service in production fails because of a configuration difference. How would you debug the issue?‚Äù

**Answer:**
My approach:

1. **Reproduce** the container locally: Pull the same image or build the version, run in similar config.
2. Check **logs** (`docker logs <container>`), inspect exit codes, check resource consumption (`docker stats`).
3. Examine **container config** vs. expected config: environment variables, mounted volumes, network mode, container image tag.
4. Compare **image versions** from each branch ‚Äî ensure tag correctly set and includes same dependencies/configs.
5. Use `docker diff <container>` or inspect filesystem to check differences in live container vs expected.
6. If a volume or bind mount is involved, verify data is present, permissions correct.
7. Use tools like `docker exec` to enter container and inspect runtime environment (installed packages, config files).
8. Once root cause is found (say a missing environment variable or mount), fix Dockerfile or Compose file, rebuild image, test, tag a version, push, and deploy with blue/green or canary strategy to avoid downtime.
   This answer shows you can handle production-level troubleshooting, which is important for senior roles.

---

### 12. What is Docker Compose and when would you use it?

**Answer:**
Docker¬†Compose is a tool for defining and running multi‚Äêcontainer applications. You define services, networks, volumes in a `docker-compose.yml` file and manage the application with commands like `docker-compose up`, `docker-compose down`.
You use it when:

* Your app consists of multiple containers (e.g., web server + database + cache).
* You want a consistent environment for development, testing, and CI.
* You need to spin up the full stack locally for testing.
  For senior SDEs, also mention how Compose integrates with CI/CD, how you can scale services (`docker-compose scale`), override configs for dev/test/prod, etc.
  ([Simplilearn.com][6])

---

### 13. What is the difference between `docker run` and `docker start`?

**Answer:**

* `docker run <image>` creates a new container from the image and starts it immediately.
* `docker start <container>` begins running a container that was previously created but stopped.
  So `run` = create + start, whereas `start` = run an existing container. Knowing this shows you understand container lifecycle nuances.
  ([Simplilearn.com][6])

---

### 14. How do you handle persistent data in containers and what happens when a container is deleted?

**Answer:**
By default, any data written inside a container (without volumes or mounts) resides in the container‚Äôs writable layer which is removed when the container is deleted. To persist data you:

* Use **volumes** (`docker volume create`, mount with `-v` or `--mount`).
* Use **bind mounts** (host directory mounted into container).
  Volumes allow data sharing between containers, easier backup/restore, and durability independent of container lifecycle. When deleting a container, if data was in a volume, it remains.
  Senior roles should also know about data migration between hosts, volume drivers, snapshots, backups, and handling stateful services in containers.
  ([Medium][5])
